In the paper "Outrageous but Meaningful Coincidences", Conor McBride described a strongly-typed representation of a dependently typed language.
This project contains an adaptation of the technique to another dependently typed language, and an interpreter for raw syntax based on it.

See the blog post for an informal overview of what this interpreter's about:
http://homotopytypetheory.org/2014/08/19/a-formalized-interpreter/

Informal details of the language:

Abstract Syntax:
(x.M) denotes an expression appropriate for metavariable M, with a new bound variable in scope.

[M] denotes a list of expressions appropriate for metavariable M.
It does _not_ denote a singleton list. Sorry.
Think of it as a naming convention. In particular, M and [M] are distinct metavariables.
[] is the empty list and [M], M conses a new element, which is written on the right. (A "snoc list".)

===============

variables (f, a, x)

types (A, B, T, F) ::= Uv | El t | Pi A (x.B)

terms (t) ::= (f,[a])

contexts (G) as lists of (x:T) bindings

===============

Typing Rules:
For some silly reason which I forget, I decided to type the argument lists in the context of the head type, rather than type whole terms as usual.
In other words, given that some hypothetical head has type F, an argument list would have type T with the head applied to it.
It technically works.
This will be one of the first idiosyncrasies to go when I try to generalize the interpreter to larger subsets of type theory.
In the mean time, enjoy this unusual presentation of function application.

===============

Types (G |- T type):

------------ TUv
G |- Uv type

f in G
G; G(f) |- [a] : Uv
-------------------- TEl
G |- El (f,[a]) type

G |- A type
G, x:A |- B type
-------------------- TPi
G |- Pi A (x.B) type

Argument Lists (G; F |- [a] : T):

-------------- LANil
G; F |- [] : F

a in G
G; F |- [a] : Pi (G(a)) (x.B)
----------------------------- LACons
G; F |- [a], a : B[a/x]

Contexts (|- G ctx):

--------- CNil
|- [] ctx

|- G ctx
G |- T type
------------- CCons
|- G, x:T ctx

===============

All these rules are in a type-checking-friendly style that I might've heard called "locally valid contexts".
One can derive judgements involving ill-formed contexts. (Like "x:El (x,[]) |- Uv type".)
This is not a problem because a judgment should only be considered meaningful when the LHS of the turnstile is.
These derivations "inside the context" can be converted to derivations "outside the context" when the LHS can be separately derived.
(The interpreter does not do that though.)

Interpretation Example:
The interpreter should interpret the derivation of

[], N:Uv, z:El (N,[]); Pi (El (N,[])) (_.El (N,[])) |- [], z : El (N,[])

as

fun (g:{g':{_:unit & Type} & projT2 g'}) (f:projT2 (projT1 g)->projT2 (projT1 g)) => f (projT2 g)

which corresponds to

fun (N:Type) (z:N) (s:N->N) => s z

by the appropriate type isomorphism.

I elided the use of a universe construction ("Typ". See TreeItrp.v.) in the middle step.
But the universe allows the injection of arbitrary types, so there should still be an isomorphism.

Files:

Utils.v				Various stuff that didn't belong elsewhere.
SimpSubst.v			De Bruijn index substitutions for SimpSyntax.v and TreeSyntax.v.

SimpSyntax.v		Simple language. Types are limited to right-nested Pi, ending in Uv.
					The domains all implicitly use El immediately.
					Uses two contexts in typing rules. This is used by Chained.v and SemiSimplicial.v.

TreeSyntax.v		The language described above. Uses one context in typing rules.
					Also has a type-preserving translation from the SimpSyntax.v language.

Context.v			Implementation of contexts, de Bruijn indexes, and substitutions for the outrageous relations.
TreeItrp.v			Interpreter for the TreeSyntax.v language.

Chained.v			Generates well-typed syntax for the type of n-truncated towers. Not currently working.
SemiSimplicial.v	Generates well-typed syntax for the type of n-truncated semisimplicial types. Incomplete and broken.
